ğŸ‘‰ Sliding Window Version (At Most Trick)
âœ… Scripted interview line (say verbatim)

â€œInstead of counting subarrays with exactly K odd numbers directly, Iâ€™ll count subarrays with at most K odd numbers and subtract subarrays with at most Kâˆ’1 odd numbers. This converts the problem into a standard sliding window.â€

ğŸ’¡ Interviewers love this sentence.

ğŸ§  Clear Intuition (Super Simple)

Counting exactly K is hard with sliding window âŒ
But counting at most K is easy âœ…

So:

Exactly K = AtMost(K) - AtMost(K-1)


Example:

AtMost(3)  â†’ all subarrays with â‰¤3 odds
AtMost(2)  â†’ all subarrays with â‰¤2 odds
Difference â†’ exactly 3 odds

ğŸš€ Helper Function: Count Subarrays with At Most K Odds
Sliding Window Idea

Expand right pointer r

Track number of odd numbers

Shrink left pointer l if odds > k

At each step, valid subarrays ending at r = (r - l + 1)

ğŸ’» C++ Code (WITH INLINE DRY RUN ğŸ‘‡)
class Solution {
public:
    // Helper function
    int atMost(vector<int>& nums, int k) {
        int left = 0;
        int countOdd = 0;
        int result = 0;

        for (int right = 0; right < nums.size(); right++) {

            // Step 1: include nums[right]
            if (nums[right] % 2 == 1)
                countOdd++;

            // Step 2: shrink window if odds > k
            while (countOdd > k) {
                if (nums[left] % 2 == 1)
                    countOdd--;
                left++;
            }

            // Step 3: count valid subarrays ending at right
            result += (right - left + 1);

            /*
            ğŸ” INLINE DRY RUN (nums=[1,1,2,1,1], k=3)

            right=0 â†’ odd=1 â†’ window=[0,0] â†’ +1
            right=1 â†’ odd=2 â†’ window=[0,1] â†’ +2
            right=2 â†’ odd=2 â†’ window=[0,2] â†’ +3
            right=3 â†’ odd=3 â†’ window=[0,3] â†’ +4
            right=4 â†’ odd=4 âŒ
                shrink:
                left=0 (odd) â†’ odd=3
            window=[1,4] â†’ +4
            */
        }
        return result;
    }

    int numberOfSubarrays(vector<int>& nums, int k) {
        return atMost(nums, k) - atMost(nums, k - 1);
    }
};

â±ï¸ Time & Space Complexity

Time: O(n)

Space: O(1) (no hashmap!)

ğŸ” Pattern Recognition (VERY IMPORTANT)
ğŸ§© This is the famous:

At Most K Sliding Window Pattern

Use this when:

Asked for exactly K

Constraint is count-based

Array contains non-negative / binary-like data

ğŸ” Similar Problems Using Same Trick

Count Number of Nice Subarrays â­

Subarrays with K Different Integers

Binary Subarrays With Sum

Max Consecutive Ones III

ğŸš« Common Mistakes

âŒ Forgetting to subtract atMost(k-1)

âŒ Using sliding window directly for â€œexactly Kâ€

âŒ Counting subarrays incorrectly (right-left+1 is key)

ğŸ§  Easy Memory Trick

â€œExactly = AtMost(K) âˆ’ AtMost(Kâˆ’1)â€

ğŸ”š Final Interview Tip

If interviewer asks:

â€œWhy does this work?â€

Say:

â€œBecause every subarray with exactly K odds is counted in atMost(K) but excluded from atMost(Kâˆ’1).â€

If you want next:

ğŸ”„ Prefix sum vs Sliding window comparison

ğŸ§ª Interview Q&A follow-ups

ğŸ§  Universal template for AtMost problems

Just say the word ğŸ‘Œ

yes

Perfect ğŸ‘
Iâ€™ll give you ALL THREE in a clean, exam-ready way.

ğŸ”¥ Prefix Sum vs Sliding Window
+ Universal AtMost(K) Template
+ Interview Follow-up Q&A
âœ… Scripted interview line (say verbatim)

â€œIf the problem asks for counting subarrays with exactly K, I first check whether the constraint is monotonic. If yes, I use the AtMost(K) sliding window trick; otherwise, I fall back to prefix sum with a hashmap.â€

ğŸ§  Prefix Sum vs Sliding Window (VERY CLEAR)
Feature	Prefix Sum + Map	Sliding Window (AtMost)
Works for negatives?	âœ… YES	âŒ NO
Extra space	O(n)	O(1)
Easy to think	Medium	Easy
Used when	Exact K, complex sums	Count-based, monotonic
Interview favorite	â­â­â­â­	â­â­â­â­â­
ğŸŸ¢ When to Use Sliding Window (AtMost)

Use it when:

Array elements are non-negative / binary / countable

Condition is monotonic

Asked for exactly K

Examples:

Odd count

Number of distinct elements

Sum of 0s and 1s

Frequency-based constraints

ğŸ”´ When to Use Prefix Sum

Use it when:

Array contains negative numbers

Condition is not monotonic

Exact sum/divisibility problems

Examples:

Subarray Sum = K

Divisible by K

Prefix difference problems

ğŸ§  UNIVERSAL TEMPLATE â€” AtMost(K)
ğŸ“Œ Memorize this (WORKS IN MANY PROBLEMS)
int atMost(vector<int>& nums, int k) {
    int left = 0;
    int ans = 0;
    int constraint = 0;

    for (int right = 0; right < nums.size(); right++) {

        // add nums[right] effect
        constraint += /* something */;

        // shrink until valid
        while (constraint > k) {
            constraint -= /* nums[left] effect */;
            left++;
        }

        // count subarrays ending at right
        ans += (right - left + 1);
    }

    return ans;
}

// EXACTLY K
return atMost(nums, k) - atMost(nums, k - 1);

ğŸ§  Easy Way to Remember

â€œRight expands, left shrinks, count += window sizeâ€

ğŸ” Problems That Use SAME TEMPLATE
Problem	Constraint
1248	Odd numbers
930	Binary sum
992	Distinct integers
1004	Zeros
1438	Absolute difference
ğŸ§ª Interview Follow-Up Questions (WITH ANSWERS)
â“ Q1: Why canâ€™t we use sliding window directly for exactly K?

âœ… Answer:

Because sliding window only guarantees correctness for monotonic constraints, not exact equality.

â“ Q2: Why does AtMost(K) âˆ’ AtMost(Kâˆ’1) work?

âœ… Answer:

Every subarray with exactly K is counted in AtMost(K) but excluded from AtMost(Kâˆ’1).

â“ Q3: Can this work with negative numbers?

âŒ No

Sliding window fails when window validity is not monotonic.

â“ Q4: Which solution is better in interviews?

âœ… Answer:

Sliding window, because it uses O(1) space and shows optimization thinking.

ğŸš« Common Exam Mistakes

âŒ Forgetting AtMost(K-1)

âŒ Using sliding window with negatives

âŒ Wrong subarray count formula

ğŸ§  Final Memory Hook

â€œExact = AtMost âˆ’ AtMostâ€

ğŸš€ You are now equipped to solve:

Prefix Sum problems

Sliding Window counting problems

Exactly K pattern questions




ğŸ‘‰ Sliding Window Version (At Most Trick)
âœ… Scripted interview line (say verbatim)

â€œInstead of counting subarrays with exactly K odd numbers directly, Iâ€™ll count subarrays with at most K odd numbers and subtract subarrays with at most Kâˆ’1 odd numbers. This converts the problem into a standard sliding window.â€

ğŸ’¡ Interviewers love this sentence.

ğŸ§  Clear Intuition (Super Simple)

Counting exactly K is hard with sliding window âŒ
But counting at most K is easy âœ…

So:

Exactly K = AtMost(K) - AtMost(K-1)


Example:

AtMost(3)  â†’ all subarrays with â‰¤3 odds
AtMost(2)  â†’ all subarrays with â‰¤2 odds
Difference â†’ exactly 3 odds

ğŸš€ Helper Function: Count Subarrays with At Most K Odds
Sliding Window Idea

Expand right pointer r

Track number of odd numbers

Shrink left pointer l if odds > k

At each step, valid subarrays ending at r = (r - l + 1)

ğŸ’» C++ Code (WITH INLINE DRY RUN ğŸ‘‡)
class Solution {
public:
    // Helper function
    int atMost(vector<int>& nums, int k) {
        int left = 0;
        int countOdd = 0;
        int result = 0;

        for (int right = 0; right < nums.size(); right++) {

            // Step 1: include nums[right]
            if (nums[right] % 2 == 1)
                countOdd++;

            // Step 2: shrink window if odds > k
            while (countOdd > k) {
                if (nums[left] % 2 == 1)
                    countOdd--;
                left++;
            }

            // Step 3: count valid subarrays ending at right
            result += (right - left + 1);

            /*
            ğŸ” INLINE DRY RUN (nums=[1,1,2,1,1], k=3)

            right=0 â†’ odd=1 â†’ window=[0,0] â†’ +1
            right=1 â†’ odd=2 â†’ window=[0,1] â†’ +2
            right=2 â†’ odd=2 â†’ window=[0,2] â†’ +3
            right=3 â†’ odd=3 â†’ window=[0,3] â†’ +4
            right=4 â†’ odd=4 âŒ
                shrink:
                left=0 (odd) â†’ odd=3
            window=[1,4] â†’ +4
            */
        }
        return result;
    }

    int numberOfSubarrays(vector<int>& nums, int k) {
        return atMost(nums, k) - atMost(nums, k - 1);
    }
};

â±ï¸ Time & Space Complexity

Time: O(n)

Space: O(1) (no hashmap!)

ğŸ” Pattern Recognition (VERY IMPORTANT)
ğŸ§© This is the famous:

At Most K Sliding Window Pattern

Use this when:

Asked for exactly K

Constraint is count-based

Array contains non-negative / binary-like data

ğŸ” Similar Problems Using Same Trick

Count Number of Nice Subarrays â­

Subarrays with K Different Integers

Binary Subarrays With Sum

Max Consecutive Ones III

ğŸš« Common Mistakes

âŒ Forgetting to subtract atMost(k-1)

âŒ Using sliding window directly for â€œexactly Kâ€

âŒ Counting subarrays incorrectly (right-left+1 is key)

ğŸ§  Easy Memory Trick

â€œExactly = AtMost(K) âˆ’ AtMost(Kâˆ’1)â€

ğŸ”š Final Interview Tip

If interviewer asks:

â€œWhy does this work?â€

Say:

â€œBecause every subarray with exactly K odds is counted in atMost(K) but excluded from atMost(Kâˆ’1).â€

If you want next:

ğŸ”„ Prefix sum vs Sliding window comparison

ğŸ§ª Interview Q&A follow-ups

ğŸ§  Universal template for AtMost problems

Just say the word ğŸ‘Œ

yes

Perfect ğŸ‘
Iâ€™ll give you ALL THREE in a clean, exam-ready way.

ğŸ”¥ Prefix Sum vs Sliding Window
+ Universal AtMost(K) Template
+ Interview Follow-up Q&A
âœ… Scripted interview line (say verbatim)

â€œIf the problem asks for counting subarrays with exactly K, I first check whether the constraint is monotonic. If yes, I use the AtMost(K) sliding window trick; otherwise, I fall back to prefix sum with a hashmap.â€

ğŸ§  Prefix Sum vs Sliding Window (VERY CLEAR)
Feature	Prefix Sum + Map	Sliding Window (AtMost)
Works for negatives?	âœ… YES	âŒ NO
Extra space	O(n)	O(1)
Easy to think	Medium	Easy
Used when	Exact K, complex sums	Count-based, monotonic
Interview favorite	â­â­â­â­	â­â­â­â­â­
ğŸŸ¢ When to Use Sliding Window (AtMost)

Use it when:

Array elements are non-negative / binary / countable

Condition is monotonic

Asked for exactly K

Examples:

Odd count

Number of distinct elements

Sum of 0s and 1s

Frequency-based constraints

ğŸ”´ When to Use Prefix Sum

Use it when:

Array contains negative numbers

Condition is not monotonic

Exact sum/divisibility problems

Examples:

Subarray Sum = K

Divisible by K

Prefix difference problems

ğŸ§  UNIVERSAL TEMPLATE â€” AtMost(K)
ğŸ“Œ Memorize this (WORKS IN MANY PROBLEMS)
int atMost(vector<int>& nums, int k) {
    int left = 0;
    int ans = 0;
    int constraint = 0;

    for (int right = 0; right < nums.size(); right++) {

        // add nums[right] effect
        constraint += /* something */;

        // shrink until valid
        while (constraint > k) {
            constraint -= /* nums[left] effect */;
            left++;
        }

        // count subarrays ending at right
        ans += (right - left + 1);
    }

    return ans;
}

// EXACTLY K
return atMost(nums, k) - atMost(nums, k - 1);

ğŸ§  Easy Way to Remember

â€œRight expands, left shrinks, count += window sizeâ€

ğŸ” Problems That Use SAME TEMPLATE
Problem	Constraint
1248	Odd numbers
930	Binary sum
992	Distinct integers
1004	Zeros
1438	Absolute difference
ğŸ§ª Interview Follow-Up Questions (WITH ANSWERS)
â“ Q1: Why canâ€™t we use sliding window directly for exactly K?

âœ… Answer:

Because sliding window only guarantees correctness for monotonic constraints, not exact equality.

â“ Q2: Why does AtMost(K) âˆ’ AtMost(Kâˆ’1) work?

âœ… Answer:

Every subarray with exactly K is counted in AtMost(K) but excluded from AtMost(Kâˆ’1).

â“ Q3: Can this work with negative numbers?

âŒ No

Sliding window fails when window validity is not monotonic.

â“ Q4: Which solution is better in interviews?

âœ… Answer:

Sliding window, because it uses O(1) space and shows optimization thinking.

ğŸš« Common Exam Mistakes

âŒ Forgetting AtMost(K-1)

âŒ Using sliding window with negatives

âŒ Wrong subarray count formula

ğŸ§  Final Memory Hook

â€œExact = AtMost âˆ’ AtMostâ€

ğŸš€ You are now equipped to solve:

Prefix Sum problems

Sliding Window counting problems

Exactly K pattern questions
