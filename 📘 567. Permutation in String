ðŸ§  Problem Statement (Simple)

Given two strings s1 and s2, return true if any permutation of s1 is a substring of s2, otherwise return false.

ðŸŽ¤ INTERVIEW SCRIPT (SAY THIS EXACTLY)

â€œMy first thought was to generate all permutations of s1 and check if any of them exists in s2, but that would be factorial time and clearly inefficient.
Since this is a permutation matching problem with a fixed window size, I optimized it using a sliding window with character frequency counting, achieving linear time complexity.â€

ðŸ’¥ This sentence alone shows brute force awareness + optimization thinking.

ðŸ§  Key Insight

Permutation â‡’ same character frequency

Window size = len(s1) â‡’ fixed sliding window

Compare frequency of s1 with every window of s2

ðŸªŸ Sliding Window Strategy

Build frequency of s1

Build frequency of first window in s2

If equal â†’ return true

Slide window:

Add right character

Remove left character

Repeat

ðŸ§ª Dry Run (Very Important in Interview)
s1 = "ab"
s2 = "eidbaooo"


Window size = 2

Window	Match
"ei"	âŒ
"id"	âŒ
"db"	âŒ
"ba"	âœ… â†’ return true
ðŸ§¾ CLEAN C++ CODE (INTERVIEW-READY)
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if (s1.size() > s2.size()) return false;

        vector<int> freq1(26, 0), freq2(26, 0);

        // Step 1: Frequency of s1
        for (char c : s1) {
            freq1[c - 'a']++;
        }

        int k = s1.size();

        // Step 2: First window frequency
        for (int i = 0; i < k; i++) {
            freq2[s2[i] - 'a']++;
        }

        // Step 3: Compare first window
        if (freq1 == freq2) return true;

        // Step 4: Slide the window
        for (int i = k; i < s2.size(); i++) {
            freq2[s2[i] - 'a']++;       // add right
            freq2[s2[i - k] - 'a']--;   // remove left

            if (freq1 == freq2)
                return true;
        }

        return false;
    }
};

â±ï¸ Complexity Analysis (Must Speak)
Metric	Value
Time	O(n)
Space	O(26) â†’ O(1)
ðŸŽ¯ PATTERN RECOGNITION

This is a Fixed Size Sliding Window + Frequency Matching problem.

Difference from 438:
Problem	Output
438	All indices
567	True / False

Same logic, different return type.

ðŸ§  ONE-LINE MEMORY HOOK

Permutation in string â‡’ Fixed window â‡’ Frequency compare

ðŸ”¥ INTERVIEW FOLLOW-UP QUESTIONS

How would you optimize array comparison?

What if characters are uppercase?

Can this be solved using hashmap?

Difference between 567 and 76?

ðŸŽ¤ FINAL POWER LINE (Say This at End)

â€œSince the window size is fixed, sliding window is the most optimal approach here.â€

ðŸ’¥ Interviewer satisfied.
