âœ… Scripted interview line (say verbatim)

â€œIâ€™ll start with a brute-force approach by checking every substring and validating word counts, but that would be inefficient. To optimize it, Iâ€™ll use a sliding window with a hashmap and move in steps of word length to ensure linear traversal.â€

ğŸ§  Clear Intuition (Very Simple)

You are given:

A string s

An array of words words (all words have same length)

You must find all starting indices where:

A substring is formed by concatenating all words exactly once

Order does not matter

No extra characters in between

ğŸ‘‰ Important facts:

All words have same length = wordLen

Total window length = wordLen * wordsCount

This screams ğŸ‘‰ Sliding Window with fixed-size chunks

âŒ Why brute force is bad

For every index, check substring of size totalLen

Break into words and count â†’ O(n Ã— wordCount) â†’ TLE

ğŸš€ Optimal Approach: Sliding Window + HashMap (WORD-BY-WORD)
Key Trick (INTERVIEW GOLD ğŸ¥‡)

Instead of moving window 1 character at a time,
ğŸ‘‰ move it wordLen characters at a time

Also:

We try wordLen different starting offsets

Because valid words must align perfectly

âœ… Algorithm (Step-by-step)

Store frequency of words in need map

For each offset i from 0 to wordLen-1:

Use sliding window:

Move right by wordLen

Track word frequencies in window

If a word count exceeds â†’ shrink from left

If window size == totalLen â†’ record answer

ğŸ’» C++ Code (WITH INLINE DRY RUN ğŸ‘‡)
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> ans;
        if (words.empty()) return ans;

        int wordLen = words[0].size();
        int wordCount = words.size();
        int totalLen = wordLen * wordCount;

        unordered_map<string, int> need;
        for (auto &w : words) need[w]++;

        // Try all possible starting offsets
        for (int i = 0; i < wordLen; i++) {
            unordered_map<string, int> window;
            int left = i, right = i;
            int count = 0;

            while (right + wordLen <= s.size()) {
                string word = s.substr(right, wordLen);
                right += wordLen;

                // If word is valid
                if (need.count(word)) {
                    window[word]++;
                    count++;

                    // Too many of same word â†’ shrink
                    while (window[word] > need[word]) {
                        string leftWord = s.substr(left, wordLen);
                        window[leftWord]--;
                        left += wordLen;
                        count--;
                    }

                    // Found valid window
                    if (count == wordCount) {
                        ans.push_back(left);
                    }
                } 
                else {
                    // Reset window
                    window.clear();
                    count = 0;
                    left = right;
                }

                /*
                ğŸ” INLINE DRY RUN
                s="barfoothefoobarman"
                words=["foo","bar"]
                wordLen=3, totalLen=6

                i=0:
                right=0 â†’ "bar" â†’ valid
                right=3 â†’ "foo" â†’ valid â†’ count=2
                count==2 â†’ ans.push_back(0)

                right=6 â†’ "the" â†’ invalid
                reset window
                */
            }
        }
        return ans;
    }
};

â±ï¸ Time & Space Complexity

Time: O(n)
(each word visited once per offset)

Space: O(m)
(m = number of words)

ğŸ” Pattern Recognition (VERY IMPORTANT)
ğŸ§© This problem is:

Sliding Window + HashMap + Fixed Word Length

Use this pattern when:

Words are same length

Order doesnâ€™t matter

Exact frequency matching required

ğŸ” Similar / Follow-up Problems

Substring with Concatenation of All Words â­

Find All Anagrams in a String

Permutation in String

Minimum Window Substring (advanced)

ğŸš« Common Mistakes

âŒ Sliding by 1 character instead of wordLen

âŒ Not handling multiple offsets

âŒ Forgetting to reset window on invalid word

âŒ Using only one hashmap

ğŸ§  Easy Memory Hook

â€œChunk the string by word length, not by characters.â€

ğŸ§ª Interview Follow-up Questions (with answers)
â“ Why do we try multiple offsets?

âœ… Because valid concatenation must align with word boundaries.

â“ Can this be done with one window?

âŒ No, misaligned words break correctness.

â“ What if word lengths are different?

ğŸ‘‰ This approach fails â†’ brute force or trie needed.
