ğŸ¤ Interview Opening Line (BRUTE FORCE â€” say this first âœ…)

â€œIâ€™ll start with a brute-force approach: Iâ€™ll check every subarray, count how many zeros it has, and if zeros â‰¤ k, Iâ€™ll update the maximum length.â€

âŒ Why Brute Force is Bad

Total subarrays = O(nÂ²)

Counting zeros inside each subarray = O(n)

Total = O(nÂ³) â†’ too slow

â¡ï¸ Now Iâ€™ll optimize it.

ğŸ¤ Transition Line (Very Important)

â€œSince we want the longest subarray with at most k zeros, I can optimize this using a sliding window.â€

âœ… Optimized Approach â€” Sliding Window (Two Pointers)
ğŸ§  Core Idea

Expand the window using right

Count number of zeros

If zeros exceed k, shrink window from left

Keep track of maximum window length

ğŸªŸ Window Rule
Valid window â†’ zeroCount â‰¤ k

ğŸ§ª Example Dry Run
nums = [1,1,1,0,0,0,1,1,1,1,0]
k = 2


Expand right

When zeros become 3 â†’ shrink from left

Best window length = 6

ğŸ§¾ Fully Commented C++ Code (with inline dry run)
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {

        int left = 0;          // start of window
        int zeroCount = 0;     // number of zeros in window
        int maxLen = 0;

        for (int right = 0; right < nums.size(); right++) {

            // include nums[right] in window
            if (nums[right] == 0)
                zeroCount++;

            // if window becomes invalid, shrink from left
            while (zeroCount > k) {
                if (nums[left] == 0)
                    zeroCount--;   // removing a zero
                left++;
            }

            // valid window here
            maxLen = max(maxLen, right - left + 1);

            /*
            Dry Run Snapshot:
            right = 5 (nums[5] = 0)
            zeroCount = 3 -> invalid
            move left until zeroCount = 2
            */
        }

        return maxLen;
    }
};

â±ï¸ Time & Space Complexity
Type	Complexity
Time	O(n)
Space	O(1)
ğŸ§  Pattern Recognition (INTERVIEW GOLD)

If you hear:

â€œlongest subarrayâ€

â€œat most kâ€

â€œflip / replace / delete k elementsâ€

ğŸ‘‰ Variable-size Sliding Window

ğŸ¤ Optimized Interview Line (Say this)

â€œThis is a variable-size sliding window because the window expands normally and shrinks only when the constraint is violated.â€

ğŸ” Follow-up Interview Questions & Variants (VERY IMPORTANT)
1ï¸âƒ£ What if you must flip exactly k zeros?

Update answer only when zeroCount == k

2ï¸âƒ£ What if k â‰¥ total zeros?

Entire array is valid
â¡ï¸ Answer = nums.size()

3ï¸âƒ£ Return the actual subarray?

Store best left and right

4ï¸âƒ£ If array had values other than 0/1?

Track â€œbad elementsâ€ instead of zeros

5ï¸âƒ£ Related Must-Do Problems
Problem	Relation
487. Max Consecutive Ones II	k = 1
424. Longest Repeating Character Replacement	Same logic
1493. Longest Subarray of 1s After Deleting One	k = 1
209. Minimum Size Subarray Sum	Shrinking window
ğŸ§  One-Line Template to Memorize
expand window â†’ fix if invalid â†’ update answer

âœ… Final Interview Takeaway

Start with brute force verbally

Then slide window confidently

This problem is guaranteed interview favorite
