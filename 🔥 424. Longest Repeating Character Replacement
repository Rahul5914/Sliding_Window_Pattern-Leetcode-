You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

 

Example 1:

Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.



âœ… Scripted interview line (say verbatim)

â€œIâ€™ll start by considering all substrings and checking if they can be made of the same character using at most K replacements, but that would be O(nÂ²). To optimize it, Iâ€™ll use a sliding window with a frequency array and track the most frequent character in the window.â€

ğŸ§  Clear Intuition (Super Simple)

We want the longest substring

We can replace at most k characters

After replacements, all characters in the window must be the same

ğŸ‘‰ Key observation:

window length - frequency of most frequent character â‰¤ k


Why?

Keep the most frequent character

Replace all other characters

ğŸš€ Optimal Approach: Sliding Window + Frequency Count
Why this works?

Window is valid if replacements needed â‰¤ k

As window grows, if invalid â†’ shrink from left

Track maximum window size

ğŸ’» C++ Code (WITH INLINE DRY RUN ğŸ‘‡)
class Solution {
public:
    int characterReplacement(string s, int k) {
        vector<int> freq(26, 0);

        int left = 0;
        int maxFreq = 0;  // max frequency of a single char in current window
        int ans = 0;

        for (int right = 0; right < s.size(); right++) {

            // Step 1: add right character
            freq[s[right] - 'A']++;
            maxFreq = max(maxFreq, freq[s[right] - 'A']);

            // Step 2: check if window is invalid
            // replacements needed = windowSize - maxFreq
            while ((right - left + 1) - maxFreq > k) {
                freq[s[left] - 'A']--;
                left++;
            }

            // Step 3: update answer
            ans = max(ans, right - left + 1);

            /*
            ğŸ” INLINE DRY RUN (s="AABABBA", k=1)

            right=0 â†’ 'A' â†’ freq[A]=1 â†’ window="A" â†’ valid â†’ ans=1
            right=1 â†’ 'A' â†’ freq[A]=2 â†’ window="AA" â†’ valid â†’ ans=2
            right=2 â†’ 'B' â†’ freq[B]=1 â†’ window="AAB"
                windowSize=3, maxFreq=2 â†’ replace=1 â‰¤k â†’ valid â†’ ans=3
            right=3 â†’ 'A' â†’ freq[A]=3 â†’ window="AABA" â†’ ans=4
            right=4 â†’ 'B' â†’ freq[B]=2 â†’ window="AABAB"
                replace=5-3=2 >k âŒ
                shrink:
                left=0 ('A') â†’ freq[A]=2
                window="ABAB" â†’ replace=4-2=2 âŒ
                left=1 ('A') â†’ freq[A]=1
                window="BAB" â†’ replace=3-2=1 âœ…
            continue...
            */
        }

        return ans;
    }
};

â±ï¸ Time & Space Complexity

Time: O(n)

Space: O(26) â†’ O(1)

ğŸ” Pattern Recognition (VERY IMPORTANT)
ğŸ§© This problem is:

Sliding Window + Frequency + AtMost(K) Replacements

Use this pattern when:

Allowed to replace â‰¤ k

Need longest substring

Characters limited (Aâ€“Z)

ğŸ” Similar Problems

Longest Repeating Character Replacement â­

Max Consecutive Ones III

Maximize the Confusion of an Exam

Max Consecutive Ones II

ğŸš« Common Mistakes

âŒ Recomputing max frequency every time (slow)

âŒ Shrinking window incorrectly

âŒ Confusion about why maxFreq isnâ€™t decreased

ğŸ§  Important Interview Trick (VERY COMMON QUESTION)
â“ Why donâ€™t we decrease maxFreq when shrinking?

âœ… Answer to say:

â€œEven if maxFreq becomes slightly outdated, the window size calculation still remains correct and guarantees the maximum length.â€

ğŸ§  Easy Memory Hook

â€œKeep maxFreq, replace the rest.â€

ğŸš€ Youâ€™ve now mastered:

Sliding Window

AtMost(K) logic

Frequency-based optimization
