ğŸ¯ UNIVERSAL TEMPLATE: ANAGRAM / PERMUTATION PROBLEMS
ğŸ¤ INTERVIEW SCRIPT (MEMORIZE & SPEAK VERBATIM)

â€œMy initial thought was a brute force approach where I generate all substrings and compare character frequencies, but that would be inefficient.
Since the problem involves checking permutations within a string, I optimized it using a sliding window with frequency counting, which reduces the time complexity to linear.â€

ğŸ’¥ This sentence works for ANY anagram / permutation problem.

ğŸ§  WHEN TO USE THIS TEMPLATE

Use immediately if the problem says:

Anagram

Permutation

Rearrangement

Same characters

Substring contains all characters

ğŸ§© CORE IDEA (1 Line)

Two strings are anagrams iff their character frequencies are equal

ğŸªŸ TEMPLATE 1: FIXED WINDOW (Most Common)

Used in:

438. Find All Anagrams in a String

567. Permutation in String

242. Valid Anagram

âœ… FIXED WINDOW SLIDING TEMPLATE (C++)
vector<int> freqPattern(26, 0);
vector<int> freqWindow(26, 0);

// Step 1: Build pattern frequency
for (char c : p)
    freqPattern[c - 'a']++;

// Step 2: Build first window
for (int i = 0; i < p.size(); i++)
    freqWindow[s[i] - 'a']++;

// Step 3: Compare first window
if (freqWindow == freqPattern)
    // valid anagram

// Step 4: Slide window
for (int i = p.size(); i < s.size(); i++) {
    freqWindow[s[i] - 'a']++;          // add right
    freqWindow[s[i - p.size()] - 'a']--; // remove left

    if (freqWindow == freqPattern)
        // valid anagram found
}

ğŸ§ª HOW TO MODIFY THIS TEMPLATE
Problem	Output
438	Store index
567	Return true
242	Compare once
ğŸªŸ TEMPLATE 2: VARIABLE WINDOW (Advanced)

Used in:

76. Minimum Window Substring

30. Substring with Concatenation of All Words

ğŸ¤ INTERVIEW SCRIPT (VARIABLE WINDOW)

â€œSince the window size is not fixed and depends on character constraints, I used a variable sliding window with a frequency map and a count tracker.â€

âœ… VARIABLE WINDOW TEMPLATE (C++)
vector<int> freq(26, 0);
int required = p.size();

// build pattern frequency
for (char c : p)
    freq[c - 'a']++;

int left = 0;

for (int right = 0; right < s.size(); right++) {

    if (freq[s[right] - 'a'] > 0)
        required--;

    freq[s[right] - 'a']--;

    // when window is valid
    while (required == 0) {
        // update answer

        freq[s[left] - 'a']++;
        if (freq[s[left] - 'a'] > 0)
            required++;

        left++;
    }
}

ğŸ§  MASTER DECISION TREE (VERY IMPORTANT)
Is order important?
 â””â”€â”€ NO â†’ Anagram / Permutation
       â”œâ”€â”€ Fixed length? â†’ Fixed Sliding Window
       â””â”€â”€ Variable length? â†’ Variable Sliding Window

ğŸ”¥ COMMON MISTAKES (INTERVIEW RED FLAGS)

âŒ Sorting substrings â†’ O(n log n)
âŒ Rebuilding frequency every window
âŒ Using extra maps when array[26] works
âŒ Forgetting to remove left character

ğŸ§  ONE-LINE MEMORY HOOK

Anagram â‡’ Frequency â‡’ Sliding Window

ğŸ“Œ PROBLEMS YOU NOW AUTO-SOLVE
LeetCode	Name
242	Valid Anagram
438	Find All Anagrams
567	Permutation in String
76	Minimum Window Substring
30	Substring with Concatenation
ğŸ¯ FINAL INTERVIEW POWER LINE

â€œThis is a classic sliding window frequency matching problem.â€

ğŸ’¥ Say this â†’ interviewer nods.
