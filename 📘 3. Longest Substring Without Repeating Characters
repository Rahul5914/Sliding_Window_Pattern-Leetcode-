ğŸ¤ INTERVIEW SCRIPT (SAY THIS EXACTLY)

â€œI first thought of checking all substrings and verifying if they contain unique characters, but that would take O(nÂ²) time.
To optimize this, I used a sliding window with a hashmap to track the last seen index of each character, reducing the time complexity to O(n).â€

ğŸ’¥ This sentence shows brute force awareness + optimization.

ğŸ§  CORE IDEA (VERY SIMPLE)

We need the longest contiguous substring

Characters must be unique

Use sliding window

Use a map to remember where a character was last seen

ğŸªŸ WHY MAP IS NEEDED HERE

Because:

We must know if a character already exists in the current window

We must jump the left pointer forward

Characters are not just counted, we store last index

ğŸ§ª EXAMPLE USED FOR DRY RUN
s = "abcabcbb"


Answer = 3 ("abc")

ğŸ§¾ C++ CODE WITH INLINE DRY RUN + COMMENTS
class Solution {
public:
    int lengthOfLongestSubstring(string s) {

        unordered_map<char, int> mp;  
        // mp[char] = last index where char appeared

        int left = 0;
        int maxLen = 0;

        // Example: s = "abcabcbb"
        for (int right = 0; right < s.size(); right++) {

            char c = s[right];

            // -------------------------------
            // If character already seen
            // and it lies inside current window
            // -------------------------------
            if (mp.find(c) != mp.end() && mp[c] >= left) {
                // Move left pointer just after last occurrence
                // Example:
                // s = "abcabcbb"
                // right = 3, c = 'a'
                // last 'a' was at index 0
                // so left = 0 + 1 = 1
                left = mp[c] + 1;
            }

            // Update last seen index of character
            mp[c] = right;

            // Current window length
            // Example: right = 2, left = 0 â†’ "abc"
            maxLen = max(maxLen, right - left + 1);
        }

        return maxLen;
    }
};

ğŸ§ª STEP-BY-STEP WINDOW MOVEMENT
s = "abcabcbb"

right=0 â†’ "a"        len=1
right=1 â†’ "ab"       len=2
right=2 â†’ "abc"      len=3
right=3 â†’ duplicate 'a' â†’ left=1 â†’ "bca"
right=4 â†’ duplicate 'b' â†’ left=2 â†’ "cab"
right=5 â†’ duplicate 'c' â†’ left=3 â†’ "abc"
right=6 â†’ duplicate 'b' â†’ left=5 â†’ "cb"
right=7 â†’ duplicate 'b' â†’ left=7 â†’ "b"


Max length = 3

â±ï¸ COMPLEXITY (SAY THIS)
Metric	Value
Time	O(n)
Space	O(n)
ğŸ§  WHY mp.find() IS USED HERE

We need to:

Check existence without creating keys

Know if character appeared inside current window

if (mp.find(c) != mp.end() && mp[c] >= left)

ğŸ¯ PATTERN RECOGNITION

This is a VARIABLE SIZE SLIDING WINDOW problem.

Use this pattern when:

Window expands & shrinks

Condition breaks (duplicate found)

Need longest / smallest substring

ğŸ§  ONE-LINE MEMORY HOOK

Duplicate found â†’ move left pointer

ğŸ¤ FINAL INTERVIEW POWER LINE

â€œThis is a classic variable sliding window problem where the left pointer jumps forward using last seen indices.â€

ğŸ’¥ Interviewer impressed.
